package main


/*1137. 第 N 个泰波那契数
泰波那契序列Tn定义如下：

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数n，请返回第 n 个泰波那契数Tn 的值。

使用矩阵快速幂，我们只需要Ologn的复杂度。
f(i) = f(i - 1) + f(i - 2) + f(i - 3)
		列向量：
				[f(i - 1)]
				[f(i - 2)]
				[f(i - 3)]
		目标所在的列向量：					展开：
				[f(i)]					[f(i - 1) * 1 + f(i - 2) * 1 + f(i - 3) * 1] ↓
				[f(i - 1)]		=		[f(i - 1) * 1 +          * 0 +          * 0]
				[f(i - 2)]				[         * 0 + f(i - 2) * 1 +          * 0]
		令
							Mat =		[1 1 1]
										[1 0 0]
										[0 1 0]
				==>
				[f(i - 1)]						[f(i - 2) + f(i - 3) + f(i - 4)]
				[f(i - 2)]		= 		Mat * 	[f(i - 2) + f(i - 3) + f(i - 4)]
				[f(i - 3)]						[f(i - 2) + f(i - 3) + f(i - 4)]

				[f(i)]							[f(i - 1) + f(i - 2) + f(i - 3)]
				[f(i - 1)]		= 		Mat^2 * [f(i - 1) + f(i - 2) + f(i - 3)]
				[f(i - 2)]						[f(i - 1) + f(i - 2) + f(i - 3)]

								...

				[f(i)]									[f(2)]
				[f(i - 1)]		= 		Mat ^ (i - 2) * [f(1)]
				[f(i - 2)]								[f(0)]
*/

func tribonacci(n int) int {
	if n == 0 {
		return 0
	} else if n == 1 || n == 2 {
		return 1
	}

	mat := [][]int{{1, 1, 1}, {1, 0, 0}, {0, 1, 0}}
	base := [][]int {{1}, {1}, {0}}

	M := matPower(n - 2, 3, mat)

	return M[0][0] * base[0][0] + M[0][1] * base[1][0] + M[0][2] * base[2][0]
}



/*
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1)= 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
*/
func fib(n int) int {
	return 0
}