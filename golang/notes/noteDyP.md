# 动态规划

目的：利用历史记录，来避免我们的重复计算。方法：把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。

步骤：定义数组元素的含义->找出数组元素之间的关系式->找出初始值

## Q1

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

定义 dp[i] 的含义为：跳上一个 i 级的台阶总共有 dp[i] 种跳法。由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]

初始值：dp[0] = 0; dp[1] = 1; dp[2] = 2;

## Q2

一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，问总共有多少条不同的路径？

定义 dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径。那么，dp[m-1][n-1] 就是我们要的答案了。dp[i][j] = dp[i-1][j] + dp[i][j-1]

初始值：

dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往右走

dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走

### 变体：

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

定义 dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，最小的路径和是 dp[i][j]。dp[i][j] = min（dp[i-1][j] + dp[i][j-1]）+ val[i][j]

## Q3

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符 删除一个字符 替换一个字符

定义 dp[i][j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]。

（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;

（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;

（3）、如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;

初始值 : dp[0] [0….n] 和 dp[0….m] [0]

## Q4

回文问题转化为倒置公共子串

## 01背包

物品限量，物品有属性：价值w（变体中经常为1），体积v（可能多维度：i.e.零一字符串最大子集问题）

经典二维：

dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

经典一维：

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]

dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

如果物品价值都是大于0的，所以dp数组初始化的时候，都初始为0

所以从后往前循环，每次取得状态不会和之前取得状态重合，j >= 物品重量

## 数值的和的组合问题

优化至一维后的结果：dp[j] += dp[j - nums[i]]

外层遍历物品，内层遍历背包容量：dp[j] 为组合数
外层容量，内层物品：dp[j]为排列数

## 完全背包

每件物品不限量

经典一维：

每件物品可以添加多次，所以从前向后遍历（使状态继承前次遍历得结果）

## 多重背包

类似01背包，备件物品给定可用数量。思路： 将 每种物品展开 --> 每件物品用一次的01背包

解法：在内部遍历背包容量时加入一个数量循环

