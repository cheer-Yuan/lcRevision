# 动态规划

目的：利用历史记录，来避免我们的重复计算。方法：把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。

步骤：定义数组元素的含义->找出数组元素之间的关系式->找出初始值

## Q1

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

定义 dp[i] 的含义为：跳上一个 i 级的台阶总共有 dp[i] 种跳法。由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]

初始值：dp[0] = 0; dp[1] = 1; dp[2] = 2;

## Q2

一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，问总共有多少条不同的路径？

定义 dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径。那么，dp[m-1][n-1] 就是我们要的答案了。dp[i][j] = dp[i-1][j] + dp[i][j-1]

初始值：

dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往右走

dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走

### 变体：

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

定义 dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，最小的路径和是 dp[i][j]。dp[i][j] = min（dp[i-1][j] + dp[i][j-1]）+ val[i][j]

## Q3

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符 删除一个字符 替换一个字符

定义 dp[i][j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]。

（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;

（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;

（3）、如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;

初始值 : dp[0] [0….n] 和 dp[0….m] [0]

## Q4

回文问题转化为倒置公共子串