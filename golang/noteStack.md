## stack 
stack : FILO, queue : FIFO
gcc : SGI STL

## container adapter
栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）

## 出栈次序种类
f(0) = 1

f(1) = 1     //即 1

f(2) = 2     //即 12、21

f(3) = 5     //即 123、132、213、321、231

然后我们来考虑f(4), 我们给4个元素编号为a,b,c,d, 那么考虑：元素a只可能出现在1号位置，2号位置，3号位置和4号位置(很容易理解，一共就4个位置，比如abcd,元素a就在1号位置)。

分析：
1) 如果元素a在1号位置，那么只可能a进栈，马上出栈，此时还剩元素b、c、d等待操作，就是子问题f(3)；

2) 如果元素a在2号位置，那么一定有一个元素比a先出栈，即有f(1)种可能顺序（只能是b），还剩c、d，即f(2)，     根据乘法原理，一共的顺序个数为f(1) * f(2)；

3) 如果元素a在3号位置，那么一定有两个元素比1先出栈，即有f(2)种可能顺序（只能是b、c），还剩d，即f(1)，

   根据乘法原理，一共的顺序个数为f(2) * f(1)；

4) 如果元素a在4号位置，那么一定是a先进栈，最后出栈，那么元素b、c、d的出栈顺序即是此小问题的解，即f(3)；


f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)*f(0)
