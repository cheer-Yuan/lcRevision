# static 作用

隐藏：当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。static 起到了对其他源文件进行隐藏与隔离错误的作用，有利于模块化程序设计。

持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围

默认初始化为0：其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置 0，然后把不是 0 的几个元素赋值。如果定义成静态的，就省去了一开始置 0 的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加 \0 太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 \0 

静态构造函数：用于在使用类之前进行相关的初始化工作；比如初始化静态成员或执行特定操作。在2次生成对象时，只调用一次

类的静态成员函数：把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用。区别：静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

三种内存分配方式：静态（编译时），栈，堆

# const 作用

表示变量只读

const int *a ：指向常整数型的指针， &a 不可修改， a 可修改

int * const a : 指向整数型的常指针

int const * a const : 整数和指针都常

# volatile 作用

优化器每次都会重新读取

例子：并行设备的硬件寄存器，多线程共享变量，

# 数据模型

按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型

# 
结构与联合有和区别？答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）

#  静态和动态库

lib+ .a

编译过程：预编译-编译-汇编-链接。在链接阶段：将汇编生成的.o与引用到的库一起打包到可执行文件中，移植方便但浪费资源。

1.利用静态库进行编译生成可执行文件时，该静态库是会直接嵌入到此可执行文件的，所以在发布程序的时候，就不需要再提供可执行文件调用到的库了，因为它本身已经包含了这些库。

2.因为可执行文件在编译时，已将自己调用到的库包含了进来，所以该可执行文件加载库的速度非常快。

1.因为库被打包进了可执行的应用程序中，当库很大时，会导致可执行文件的体积很大。

2.当库被更新时，需要重新编译程序，如果程序很大，则是个很耗时的事情。



动态库在程序运行时再链接库函数

优点
1.执行程序的体积小；

2.动态库更新后，不需要重新编译程序，前提条件是函数的接口没有改变，函数的内容可以改变。

缺点
1.在发布程序时需要将动态库提供给用户；

2.动态库没有被打包到应用程序中，加载速度相对较慢。

# inline

对编译器的建议，将函数调用替换展开成代码，避免频繁调用对栈内存的消耗。适用：非复杂函数，不包含复杂结构控制，非递归

关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。

定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。

# reference 引用

是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

引用很容易与指针混淆，它们之间有三个主要的不同：

不存在空引用。引用必须连接到一块合法的内存。

一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。

引用必须在创建时被初始化。指针可以在任何时间被初始化。

int i = 17;

int&  r = i;  //为 i 声明引用变量

作用：传参（常量引用，更安全），返回值（运算符重载），别名

void NormalizeBigString(const string& input, string* output) {
... ...
}

返回内部对象的常量引用：

struct MachineConfig { ... /* 许多许多的配置选项 */ ... }

class FancyMachine {

private:

Config config_;  // 这台机器的配置选项信息

public:

// 一能让外界访问配置，二能避免拷贝，三能避免不受控制的配置变化

const Config& config() { return config_; }

};

